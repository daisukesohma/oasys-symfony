<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

declare(strict_types=1);

namespace App\Infrastructure\Dao;

use App\Domain\Enum\EventStatusEnum;
use App\Domain\Enum\EventTypeEnum;
use App\Domain\Enum\ProgramStatusEnum;
use App\Domain\Enum\UserTypeEnum;
use App\Domain\Exception\NotFound;
use App\Domain\Model\Candidate;
use App\Domain\Model\Event;
use App\Domain\Model\Program;
use App\Domain\Model\User;
use App\Domain\Repository\UserRepository;
use App\Infrastructure\Dao\Generated\AbstractUserDao;
use App\Infrastructure\Iterator\CompositionResultIterator;
use App\Infrastructure\Logging\ModelLogger;
use Doctrine\Common\Cache\Cache;
use Mouf\Database\MagicQuery;
use Mouf\Database\SchemaAnalyzer\SchemaAnalyzer;
use Porpaginas\Result;
use Safe\DateTimeImmutable;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use TheCodingMachine\TDBM\ConfigurationInterface;
use TheCodingMachine\TDBM\OrderByAnalyzer;
use TheCodingMachine\TDBM\ResultIterator;
use TheCodingMachine\TDBM\TDBMSchemaAnalyzer;
use TheCodingMachine\TDBM\TDBMService;
use function assert;
use function count;
use function explode;
use function implode;
use function in_array;

/**
 * The UserDao class will maintain the persistence of User class into the users table.
 */
class UserDao extends AbstractUserDao implements UserRepository
{
    use ModelLogger;
    use CompositionDao;

    public const SORT_COLUMNS = [
        'name' => 'last_name',
        'createdAt' => 'users.created_at',
        'status' => 'status',
    ];

    private TokenStorageInterface $tokenStorage;
    private Cache $cache;
    private OrderByAnalyzer $orderByAnalyzer;
    private SchemaAnalyzer $schemaAnalyzer;
    private TDBMSchemaAnalyzer $tdbmSchemaAnalyzer;
    private MagicQuery $magicQuery;
    private string $cachePrefix;

    public function __construct(TDBMService $tdbmService, TokenStorageInterface $tokenStorage, ConfigurationInterface $configuration)
    {
        parent::__construct($tdbmService);

        $this->tokenStorage = $tokenStorage;
        $this->cache = $configuration->getCache();
        $this->schemaAnalyzer = $configuration->getSchemaAnalyzer();
        $this->tdbmSchemaAnalyzer = new TDBMSchemaAnalyzer($this->tdbmService->getConnection(), $this->cache, $this->schemaAnalyzer);
        $this->cachePrefix = $this->tdbmSchemaAnalyzer->getCachePrefix();
        $this->orderByAnalyzer = new OrderByAnalyzer($this->cache, $this->cachePrefix);
        $this->magicQuery = new MagicQuery($this->tdbmService->getConnection(), $this->cache, $this->schemaAnalyzer);
    }

    /**
     * @param String[] $filters
     * @param String[] $params
     */
    private function userTypeFilter(array &$filters, array &$params): void
    {
        $userType = $this->getLoggedUser()->getType()->getId();

        switch ($userType) {
            case UserTypeEnum::COACH:
                $filters[] = 'coach_id = :coach';
                $params['coach'] = $this->getLoggedUser()->getId();
                break;
        }
    }

    protected function getTokenStorage(): TokenStorageInterface
    {
        return $this->tokenStorage;
    }

    protected function getUserRepository(): UserRepository
    {
        return $this;
    }

    public function save(User $user): void
    {
        $this->log($user);
        parent::save($user);
    }

    public function saveNoLog(User $user): void
    {
        parent::save($user);
    }

    /**
     * @throws NotFound
     */
    public function mustFindOneById(string $id): User
    {
        $user = $this->findOne(['id' => $id]);
        if ($user === null) {
            throw new NotFound(User::class, ['id' => $id]);
        }

        return $user;
    }

    /**
     * @param string[] $types
     *
     * @return User[]|ResultIterator
     */
    public function findByFilters(?string $search = null, ?string $companyName = null, ?array $types = null, ?string $roleId = null, ?string $companyId = null, ?string $programId = null, ?string $coachId = null, ?string $sortColumn = null, ?string $sortDirection = null): ResultIterator
    {
        $query = 'users JOIN users_roles ON users.id = users_roles.user_id';

        $filters = ['users.deleted = 0'];
        $parameter = [];

        if (! empty($search)) {
            $searchValues = explode(' ', $search);
            $filtersTmp = '(';
            foreach ($searchValues as $key => $value) {
                $filtersTmp .= 'first_name LIKE :champ' . $key . ' OR last_name LIKE :champ' . $key . ' OR email LIKE :champ' . $key;
                $parameter['champ' . $key] = '%' . $value . '%';

                if ($key === count($searchValues) - 1) {
                    continue;
                }

                $filtersTmp .= ' OR ';
            }
            $filtersTmp .= ')';
            $filters[] = $filtersTmp;
        }

        if (! empty($companyName) && empty($companyId)) {
            $filters[] = 'companies.name LIKE :company';
            $query .= ' JOIN companies ON users.company_id = companies.id';
            $parameter['company'] = '%' . $companyName . '%';
        }

        if (! empty($companyId)) {
            $filters[] = 'company_id = :company';
            $parameter['company'] = $companyId;
        }

        if (! empty($programId)) {
            $filters[] = 'programs_users.program_id = :programId';
            $query .= ' JOIN programs_users ON (programs_users.user_id = users.id)';
            $parameter['programId'] = $programId;
        }

        if (! empty($roleId)) {
            $filters[] = 'users_roles.role_id=:role';
            $parameter['role'] = $roleId;
        }

        if (! empty($coachId)) {
            $filters[] = 'coach_id = :coachId';
            $parameter['coachId'] = $coachId;
        }

        $orderBy = null;
        if (! empty($sortColumn) && isset(self::SORT_COLUMNS[$sortColumn])) {
            $orderBy = self::SORT_COLUMNS[$sortColumn] . ' ' . ($sortDirection === 'asc' ? 'ASC' : 'DESC');
        }

        $this->userTypeFilter($filters, $parameter);

        if (! empty($types)) {
            $filters[] = 'type_id IN (:types)';
            $parameter['types'] = $types;
        }

        return $this->findFromSql($query, $filters, $parameter, $orderBy);
    }

    /**
     * @return User[]|ResultIterator
     */
    public function findUsersToAssociateToProgram(?string $search = null, ?string $companyId = null): ResultIterator
    {
        $query = 'users';

        $filters = [];
        $parameters = [];

        if ($this->getLoggedUser()->getType()->getId() !== UserTypeEnum::ADMINISTRATOR) {
            $query .= '
                LEFT JOIN programs_users ON users.id = programs_users.user_id
                LEFT JOIN programs ON programs_users.program_id = programs.id
            ';
            $filters[] = 'users.type_id = :typeCandidate OR users.type_id = :typeCoach';
            $parameters['typeCandidate'] = UserTypeEnum::CANDIDATE;
            $parameters['typeCoach'] = UserTypeEnum::COACH;

            $filters[] = 'programs.id IS NULL OR programs.status != :status';
            $parameters['status'] = ProgramStatusEnum::INPROGRESS;

            if ($this->getLoggedUser()->getType()->getId() === UserTypeEnum::COACH) {
                $filters[] = 'users.coach_id = :user OR (users.coach_id IS NULL AND users.type_id = :typeCoach)';
                $parameters['user'] = $this->getLoggedUser()->getId();
            }
        }

        if (! empty($search)) {
            $filters[] = 'users.first_name LIKE :search OR users.last_name LIKE :search OR users.email LIKE :search';
            $parameters['search'] = '%' . $search . '%';
        }

        if (! empty($companyId)) {
            $filters[] = 'users.company_id = :companyId';
            $parameters['companyId'] = $companyId;
        }

        $orderBy = 'users.last_name ASC';

        return $this->findFromSql($query, $filters, $parameters, $orderBy);
    }

    public function getLoggedUser(): User
    {
        return $this->_getUser();
    }

    /**
     * Checks if the given email is unique. Using findOneByEmail has significant overhead which we do not need for simple
     * input validation
     */
    public function checkEmailUnique(string $email, ?string $userId = null): bool
    {
        $query = $this->tdbmService->getConnection()->executeQuery('
            SELECT id FROM users
            WHERE email = :email' . ($userId !== null ? ' AND id != :userId' : '') . '
            LIMIT 1
        ', ['email' => $email, 'userId' => $userId]);

        return count($query->fetchAll()) === 0;
    }

    /**
     * @param string[]|null $statuses
     *
     * @return Candidate[]|CompositionResultIterator
     */
    public function getFilteredCandidates(User $coach, ?string $email, ?string $lastName, ?string $firstName, ?array $statuses = null, ?string $programType = null, ?string $eventType = null, ?string $date = null): CompositionResultIterator
    {
        $filters = ['programs_coaches.coach_id = :coach', 'users.coach_id = :coach', 'programs.deleted = :deleted'];
        $parameters = ['coach' => $coach->getId(), 'deleted' => 0];
        $from = '
            users
            JOIN programs_users ON programs_users.user_id = users.id
            JOIN programs ON programs_users.program_id = programs.id
            JOIN programs_coaches ON (programs_coaches.program_id = programs.id)
            LEFT JOIN (SELECT * FROM program_coaching_individuals) AS program_coaching_individuals ON program_coaching_individuals.id = programs.id
            LEFT JOIN (SELECT * FROM program_outplacement) AS program_outplacement ON program_outplacement.id = programs.id
            LEFT JOIN (SELECT * FROM program_pic) AS program_pic ON program_pic.id = programs.id
            LEFT JOIN (
                SELECT events_users.user_id, events.program_id, MIN(events.date_event) AS minDateEvent
                FROM events
                    JOIN events_users ON (events_users.event_id = events.id)
                WHERE events.status = :statusUpcoming
                GROUP BY events_users.user_id, events.program_id
            ) AS events ON (
                events.user_id = users.id
                    AND events.program_id = programs.id
            )
            LEFT JOIN (
                SELECT events_users.user_id, events.program_id
                FROM events
                    JOIN events_users ON (events_users.event_id = events.id)
                WHERE events.status = :statusOngoing
                GROUP BY events_users.user_id, events.program_id
            ) AS eventsOngoing ON (
                eventsOngoing.user_id = users.id
                    AND eventsOngoing.program_id = programs.id
            )
        ';

        if (! empty($statuses) || ! empty($eventType) || ! empty($date)) {
            $fromFilter = [];
            if (! empty($statuses)) {
                $statusClause = [];
                foreach ($statuses as $k => $status) {
                    $parameters['status_' . $k] = $status;
                    $statusClause[] = ':status_' . $k;
                }
                $fromFilter[] = 'events.status IN (' . implode(', ', $statusClause) . ')';
            }
            if (! empty($eventType) && in_array($eventType, EventTypeEnum::values())) {
                $fromFilter[] = 'events.type = :type';
                $parameters['type'] = $eventType;
            }
            if (! empty($date)) {
                $fromFilter[] = 'events.date_event >= :minDate AND events.date_event <= :maxDate';
                $parameters['minDate'] = (new DateTimeImmutable($date))->format('Y-m-d') . ' 00:00:00';
                $parameters['maxDate'] = (new DateTimeImmutable($date))->format('Y-m-d') . ' 23:59:59';
            }
            $from .= '
                    LEFT JOIN (SELECT events.program_id FROM events WHERE ' . implode(' AND ', $fromFilter) . ') AS eventFilter ON (eventFilter.program_id = programs.id)';
            $filters[] = 'eventFilter.program_id IS NOT NULL';
        }

        if (empty($statuses) || ! in_array('finished', $statuses)) {
            $filters[] = 'programs.status != :statusArchived';
            $filters[] = 'programs.status != :statusFinished';
            $parameters['statusArchived'] = ProgramStatusEnum::ARCHIVED;
            $parameters['statusFinished'] = ProgramStatusEnum::FINISHED;
        }

        if (! empty($email)) {
            $filters[] = 'users.email LIKE :email';
            $parameters['email'] = '%' . $email . '%';
        }

        if (! empty($firstName)) {
            $filters[] = 'users.first_name LIKE :firstName';
            $parameters['firstName'] = '%' . $firstName . '%';
        }

        if (! empty($lastName)) {
            $filters[] = 'users.last_name LIKE :lastName';
            $parameters['lastName'] = '%' . $lastName . '%';
        }

        if (! empty($programType)) {
            $filters[] = 'programs.type = :programType';
            $parameters['programType'] = $programType;
        }

        $parameters['statusOngoing'] = EventStatusEnum::ONGOING;
        $parameters['statusUpcoming'] = EventStatusEnum::UPCOMING;

        /** @var CompositionResultIterator|Candidate[] $result */
        $result = $this->findCompositionObjects(
            ['users', 'programs'],
            $from,
            $filters,
            $parameters,
            'hasOngoingEvent DESC, hasNextEvent DESC, minDateEvent ASC, users.last_name ASC, users.first_name ASC',
            fn(array $tuple, array $row) => new Candidate($tuple[0], $tuple[1], $this),
            [
                'IF (minDateEvent IS NULL, 0, 1) AS hasNextEvent',
                'minDateEvent',
                'IF (eventsOngoing.program_id IS NULL, 0, 1) AS hasOngoingEvent',
            ],
        );

        return $result;
    }

    public function getNextEvent(string $userId): ?Event
    {
        /** @var Event[] $result */
        $result = $this->findCompositionObjects(
            ['events'],
            'events JOIN events_users ON (events_users.event_id = events.id)',
            ['events_users.user_id = :userId', 'events.status = :ongoing OR events.status = :upcoming'],
            ['userId' => $userId, 'ongoing' => EventStatusEnum::ONGOING, 'upcoming' => EventStatusEnum::UPCOMING],
            'events.date_event ASC',
            static fn(array $tuple, array $row) => $tuple[0],
        )->take(0, 1)->toArray();

        return $result[0] ?? null;
    }

    public function getProgramEventsForCandidate(Program $program, User $candidate, bool $fetchOnlyAttending = false, ?string $dateStart = null, ?string $dateEnd = null): CompositionResultIterator
    {
        /** @var CompositionResultIterator|Event[] $result */
        $result = $this->findCompositionObjects(
            ['events', 'programs'],
            'events
                LEFT JOIN events_users ON (events_users.event_id = events.id AND events_users.user_id = :userId)
                LEFT JOIN programs ON (programs.id = events.program_id)
                LEFT JOIN program_coaching_individuals ON (program_coaching_individuals.id = programs.id)
                LEFT JOIN program_outplacement ON (program_outplacement.id = programs.id)
                LEFT JOIN program_pic ON (program_pic.id = programs.id)
            ',
            [
                'events.program_id = :programId' .
                ($fetchOnlyAttending ? ' AND events_users.user_id IS NOT NULL' : '') .
                (! empty($dateStart) ? ' AND events.date_event >= :dateStart AND events.date_event <= :dateEnd' : ''),
            ],
            [
                'userId' => $candidate->getId(),
                'programId' => $program->getId(),
                'dateStart' => $dateStart !== null ? (new DateTimeImmutable($dateStart))->format('Y-m-d H:i:s') : $dateStart,
                'dateEnd' => $dateEnd !== null ? (new DateTimeImmutable($dateEnd))->format('Y-m-d H:i:s') : $dateEnd,
            ],
            'events.date_event ASC',
            static function (array $tuple, array $row): Event {
                $event = $tuple[0];
                assert($event instanceof Event);
                $event->setIsAttending($row['isAttending'] === '1');

                if ($tuple[1] !== null && $tuple[1] instanceof Program) {
                    $event->setProgram($tuple[1]);
                }

                return $event;
            },
            ['IF (events_users.user_id IS NULL, 0, 1) AS isAttending']
        );

        return $result;
    }

    /**
     * @return Event[]|CompositionResultIterator
     */
    public function getEventsWithoutProgram(string $userId): CompositionResultIterator
    {
        /** @var CompositionResultIterator|Event[] $result */
        $result = $this->findCompositionObjects(
            ['events'],
            '
                events
                JOIN events_users ON (events_users.event_id = events.id)
                LEFT JOIN programs_users ON (programs_users.program_id = events.program_id AND programs_users.user_id = :userId)
            ',
            ['programs_users.user_id IS NULL', 'events_users.user_id = :userId', 'events.status = :ongoing OR events.status = :upcoming'],
            ['userId' => $userId, 'ongoing' => EventStatusEnum::ONGOING, 'upcoming' => EventStatusEnum::UPCOMING],
            'events.date_event ASC',
            static fn(array $tuple, array $row) => $tuple[0],
        );

        return $result;
    }

    /**
     * @return Result|User[]
     */
    public function getUsersForProgram(string $programId): Result
    {
        /** @var Result|User[] $result */
        $result = $this->find('programs_users.program_id = :programId', ['programId' => $programId]);

        return $result;
    }

    /**
     * @throws NotFound
     */
    public function mustFindCandidateById(string $id, ?string $programId = null): Candidate
    {
        $user = $this->mustFindOneById($id);
        if ($user->getType()->getId() !== UserTypeEnum::CANDIDATE) {
            throw new NotFound(Candidate::class, ['id' => $id]);
        }
        $programs = $user->getProgramsByProgramsUsers();
        if (empty($programs)) {
            throw new NotFound(Candidate::class, ['id' => $id]);
        }

        $candidateProgram = $programs[0] ?? $programs[1];
        if ($programId !== null) {
            foreach ($programs as $program) {
                if ($program->getId() !== $programId) {
                    continue;
                }

                $candidateProgram = $program;
            }
        }

        return new Candidate($user, $candidateProgram, $this);
    }

    /**
     * @return ResultIterator|User[]
     */
    public function findUsersForExport(): ResultIterator
    {
        return $this->find('deleted = 0');
    }
}
