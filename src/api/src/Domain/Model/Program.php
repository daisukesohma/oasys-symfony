<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

declare(strict_types=1);

namespace App\Domain\Model;

use App\Domain\Enum\EventStatusEnum;
use App\Domain\Enum\ProgramTypeEnum;
use App\Domain\Exception\InvalidStringValue;
use App\Domain\Exception\NotFound;
use App\Domain\Logging\LoggableModel;
use App\Domain\Model\Generated\AbstractProgram;
use App\Domain\Repository\UserRepository;
use DateTimeImmutable as UnsafeDateTimeImmutable;
use Porpaginas\Result;
use TheCodingMachine\GraphQLite\Annotations\Autowire;
use TheCodingMachine\GraphQLite\Annotations\Field;
use TheCodingMachine\GraphQLite\Annotations\Logged;
use TheCodingMachine\GraphQLite\Annotations\Type;
use TheCodingMachine\TDBM\AlterableResultIterator;
use function array_filter;
use function in_array;
use function Safe\sprintf;

/**
 * The Program class maps the 'programs' table in database.
 *
 * @Type
 */
class Program extends AbstractProgram implements LoggableModel
{
    /**
     * @throws InvalidStringValue
     */
    public function setName(string $name): void
    {
        $property = 'name';
        InvalidStringValue::notBlank($name, $property);
        InvalidStringValue::length($name, 1, 255, $property);
        parent::setName($name);
    }

    public function setDateStart(?UnsafeDateTimeImmutable $dateStart): void
    {
        parent::setDateStart($dateStart);
    }

    public function setDateEnd(?UnsafeDateTimeImmutable $dateEnd): void
    {
        parent::setDateEnd($dateEnd);
    }

    /**
     * @throws InvalidStringValue
     */
    public function setType(string $type): void
    {
        if (! in_array($type, ProgramTypeEnum::values())) {
            throw new InvalidStringValue(sprintf('The type %s is not one of the valid types', $type), 400);
        }
        parent::setType($type);
    }

    /**
     * @return Result|Event[]
     *
     * @throws NotFound
     *
     * @Field
     * @Autowire(for="$userRepository")
     * @Logged
     */
    public function getEventsOrderedByDate(UserRepository $userRepository, ?string $userId = null, bool $fetchOnlyAttending = false, ?string $dateStart = null, ?string $dateEnd = null): Result
    {
        if ($userId !== null) {
            $user = $userRepository->mustFindOneById($userId);

            return $userRepository->getProgramEventsForCandidate($this, $user, $fetchOnlyAttending, $dateStart, $dateEnd);
        }

        return $this->retrieveManyToOneRelationshipsStorage(
            'events',
            'from__program_id__to__table__programs__columns__id_ordered_by_date',
            ['events.program_id' => $this->get('id', 'programs')],
            'events.date_event ASC',
        );
    }

    public function getNextEvent(): ?Event
    {
        return $this->retrieveManyToOneRelationshipsStorage(
            'events',
            'from__program_id__to__table__programs__columns__id__next',
            ['events.program_id' => $this->getId(), 'status = "' . EventStatusEnum::ONGOING . '" OR status = "' . EventStatusEnum::UPCOMING . '"'],
            'date_event ASC',
        )->first();
    }

    /**
     * @return AlterableResultIterator|Event[]
     *
     * @Field
     * @Logged
     */
    public function getCompletedEvents(): AlterableResultIterator
    {
        return $this->retrieveManyToOneRelationshipsStorage(
            'events',
            'from__program_id__to__table__programs__columns__id__completed',
            ['events.program_id' => $this->getId(), '(status = "' . EventStatusEnum::FINISHED . '" OR status = "' . EventStatusEnum::ARCHIVED . '")'],
            'date_event ASC',
        );
    }

    /**
     * @return AlterableResultIterator|Todo[]
     *
     * @throws NotFound
     *
     * @Field
     * @Autowire(for="$userRepository")
     * @Logged
     */
    public function getTodos(?UserRepository $userRepository = null, ?string $userId = null): AlterableResultIterator
    {
        $filters = ['todos.program_id' => $this->get('id', 'programs'), 'done' => false];
        if ($userRepository !== null && $userId !== null) {
            $user = $userRepository->mustFindOneById($userId);
            $filters[] = 'todos.user_id = "' . $user->getId() . '"';
        }

        return $this->retrieveManyToOneRelationshipsStorage(
            'todos',
            'from__program_id__to__table__programs__columns__id',
            $filters,
        );
    }

    /**
     * @return Result|User[]
     *
     * @Field
     * @Autowire(for="$userRepository")
     * @Logged
     */
    public function getUsers(UserRepository $userRepository): Result
    {
        return $userRepository->getUsersForProgram($this->getId());
    }

    /**
     * @return User[]
     *
     * @Field
     * @Logged
     */
    public function getCoaches(): array
    {
        return $this->getUsersByProgramsCoaches();
    }

    /**
     * @return User[]
     *
     * @Field
     * @Logged
     */
    public function getUsersByProgramsUsers(): array
    {
        return array_filter(parent::getUsersByProgramsUsers(), static fn (User $user) => ! $user->getDeleted());
    }

    /**
     * @Field
     * @Logged
     */
    public function getCreatedBy(): ?User
    {
        return parent::getCreatedBy();
    }

    /**
     * @Field
     * @Logged
     */
    public function getUpdatedBy(): ?User
    {
        return parent::getUpdatedBy();
    }

    /**
     * @Field
     * @Logged
     */
    public function getCreatedAt(): ?UnsafeDateTimeImmutable
    {
        return parent::getCreatedAt();
    }

    /**
     * @Field
     * @Logged
     */
    public function getUpdatedAt(): ?UnsafeDateTimeImmutable
    {
        return parent::getUpdatedAt();
    }

    /**
     * @Field
     * @Logged
     */
    public function getPeriod(): ?int
    {
        return parent::getPeriod();
    }
}
